---
layout: default
title: Government grant award search
---

<script src="jquery.min.js"></script>
<script src="jszip.min.js"></script>
<script src="papaparse.min.js"></script>

<h1>Federal government grant award search</h1>
<p class="text-sm md:text-[15px]">
  Below is a keyword search over a selection of active federal government grants.
  Each typed word is treated as an <strong>AND</strong> condition (i.e., all must match).
  This search runs in two passes per keyword:
  (1) exact keyword match,
  (2) prefix matches (i.e., other keywords that start with that string).
  For performance reasons, only the first 100 matching rows are displayed.  
</p>
<p class="text-sm md:text-[15px] mb-4">
  You can search by <abbr title="Employer Identification Number">EIN</abbr> (eg: 13-2574854), <abbr title="Unique Entity Identifier">UEI</abbr> (eg: M2NYTB5V2D77) or keywords (eg: unaccompanied refugee)
</p>

<div id="searchContainer" class="mb-2">
  <div class="flex flex-col md:flex-row md:items-center gap-1 justify-between">
    <form id="searchForm" class="flex flex-col md:flex-row md:items-center gap-1 w-full">
      <label for="searchBox" class="text-sm md:text-[15px]">Enter keywords:</label>
      <span class="flex items-center gap-1">
      <input type="text" id="searchBox" class="w-full md:w-auto px-2 py-1 rounded text-sm border border-gray-300" placeholder="Keywords, EIN, UEI" autofocus />
      <button type="submit" id="searchButton" class="bg-slate-900 py-1 px-2 text-sm font-medium text-white rounded md:mr-2 min-w-[65px]" disabled>
        <span class="button-text">Search</span>
        <img src="/assets/images/loading-white.svg" class="loading-spinner size-6 mx-auto" style="display: none;" alt="Loading..." />
      </button>
      </span>
      <span id="statusMessage"></span>
    </form>
    <div>
      <div id="resultsStatus"></div>
    </div>
  </div>
</div>


<div id="statsBox" class="empty:hidden my-2"></div> <!-- Will display the sum of award_amount here -->

<div id="resultsContainer" class="flex flex-col gap-2"></div>

<script>
  // These will be filled after we parse award_reverse_index.txt.zip
  let KEYWORDS = [];
  let BATCHES  = [];

  // Keep track of total taxpayer money across displayed results
  let totalAwardAmount = 0;

  // Disable the form until the index is loaded
  $('#searchBox').prop('disabled', true);
  $('#searchButton').prop('disabled', true);

  // Once the document is ready, fetch and parse the master reverse index
  $(document).ready(async function() {
    $('#statusMessage').html('<span class="inline-flex text-[13px]">Loading data...</span>');
    try {
      // Show loading spinner in button while loading
      $('#searchButton .button-text').hide();
      $('#searchButton .loading-spinner').show();
      
      await loadMasterReverseIndex('award_reverse_index.txt.zip');
      
      // Hide loading spinner and show text when done
      $('#searchButton .loading-spinner').hide();
      $('#searchButton .button-text').show();
      
      $('#statusMessage').hide();
      $('#searchBox').prop('disabled', false).focus();
      $('#searchButton').prop('disabled', false);
      
      // After index is loaded, check URL parameters and perform search if needed
      const urlParams = new URLSearchParams(window.location.search);
      const keywords = urlParams.get('keywords');
      if (keywords) {
        $('#searchBox').val(keywords);
        $('#searchForm').trigger('submit');
      }
    } catch (err) {
      console.error(err);
      $('#statusMessage').text('Error loading index: ' + err);
    }
  });

  // Attach search handler
  $('#searchForm').on('submit', async function(e) {
    e.preventDefault();
    // Clear previous results
    $('#resultsContainer').empty();
    $('#statsBox').text('');
    totalAwardAmount = 0; // reset the sum

    // Disable search while performing the operation
    $('#searchBox').prop('disabled', true);
    $('#searchButton').prop('disabled', true);

    // Show loading spinner while searching
    $('#searchButton .button-text').hide();
    $('#searchButton .loading-spinner').show();

    try {
      const userInput = $('#searchBox').val().trim();
      
      // Update URL with search terms without triggering page reload
      const newUrl = new URL(window.location);
      if (userInput) {
        newUrl.searchParams.set('keywords', userInput);
      } else {
        newUrl.searchParams.delete('keywords');
      }
      window.history.pushState({}, '', newUrl);

      // 1) Parse user input => tokens
      const tokens = tokenizeInput(userInput);
      if (!tokens.length) {
        $('#resultsContainer').hide();
        $('#resultsContainer').html(
          '<div class="p-4 text-center">No valid keywords to search for.</div>'
        ).show();
        $('#resultsStatus').empty();
      } else {
        // 2) For each token, gather the union of exact + prefix matches => then intersect across tokens
        const finalBatchIDs = getFinalBatchIntersection(tokens);

        // 3) Load data from each batch (in ascending order) until we have 100 rows
        const sortedBatchIDs = Array.from(finalBatchIDs).sort((a, b) => a - b);
        let totalRowsDisplayed = 0;
        for (let i = 0; i < sortedBatchIDs.length && totalRowsDisplayed < 100; i++) {
          const batchId = sortedBatchIDs[i];
          totalRowsDisplayed += await processBatch(batchId, tokens, 100 - totalRowsDisplayed);
        }

        // Update status based on results
        if (totalRowsDisplayed > 0) {
          $('#resultsContainer').show();
          $('#resultsStatus').html(
            `<span class="text-sm whitespace-nowrap">Showing ${totalRowsDisplayed}${totalRowsDisplayed === 100 ? ' (limit)' : ''} results</span>`
          );
          $('#statsBox').html(`<div class="p-2 rounded border border-gray-200 bg-white text-center md:text-left"><span class="text-black text-sm">Taxpayer money spent:</span> <strong class="text-red-500">${formatCurrency(totalAwardAmount)}</strong></div>`);
        } else {
          $('#resultsContainer').html(
            '<div class="p-4 text-center">No results found.</div>'
          ).show();
          $('#resultsStatus').empty();
        }
      }
    } catch (err) {
      console.error(err);
      $('#resultsContainer').html(
        '<div class="p-4 text-center">Error during search: ' + err + '</div>'
      ).show();
      $('#resultsStatus').empty();
    }

    // Hide loading spinner when done
    $('#searchButton .loading-spinner').hide();
    $('#searchButton .button-text').show();

    // Re-enable search
    $('#searchBox').prop('disabled', false);
    $('#searchButton').prop('disabled', false);
  });


  // ============================================================
  // 1) LOAD AND PARSE THE MASTER REVERSE INDEX
  // ============================================================
  async function loadMasterReverseIndex(zipUrl) {
    const response = await fetch(zipUrl);
    if (!response.ok) {
      throw new Error('Could not fetch ' + zipUrl);
    }
    const arrayBuffer = await response.arrayBuffer();

    const jsZip = new JSZip();
    const zip = await jsZip.loadAsync(arrayBuffer);

    // We expect a single file "award_reverse_index.txt" inside
    const fileName = 'award_reverse_index.txt'; // Known from instructions
    if (!zip.file(fileName)) {
      throw new Error('Zip does not contain ' + fileName);
    }

    const fileData = await zip.file(fileName).async('string');
    parseMasterReverseIndex(fileData);
  }

  function parseMasterReverseIndex(text) {
    // Each line is: keyword:batch_id1,batch_id2,...
    // Lines are in alphabetical order
    const lines = text.split(/\r?\n/);
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue; // skip empty
      const parts = trimmed.split(':');
      if (parts.length !== 2) continue; // skip malformed

      const kw = parts[0];
      const batchString = parts[1];
      const batchIds = batchString.split(',').map(x => parseInt(x, 10)).filter(n => !isNaN(n));

      KEYWORDS.push(kw);
      BATCHES.push(batchIds);
    }
  }

  // ============================================================
  // 2) TOKENIZE USER INPUT
  // ============================================================
  function tokenizeInput(input) {
    // 1) lowercase
    let txt = input.toLowerCase();
    // 2) remove hyphens
    txt = txt.replace(/-/g, '');
    // 3) replace all other punctuation / non-alphanumeric with whitespace
    txt = txt.replace(/[^a-z0-9]+/g, ' ');
    // 4) split by whitespace
    const rawTokens = txt.split(/\s+/).map(t => t.trim()).filter(Boolean);

    // 5) discard tokens that cannot be found as a prefix in KEYWORDS
    const validTokens = [];
    for (const t of rawTokens) {
      if (couldPrefixMatch(t)) {
        validTokens.push(t);
      }
    }
    return validTokens;
  }

  function couldPrefixMatch(token) {
    // Binary-search approach to see if there's any keyword that starts with 'token'
    const startIdx = findInsertionIndex(KEYWORDS, token);
    if (startIdx >= KEYWORDS.length) return false;
    return KEYWORDS[startIdx].startsWith(token);
  }

  // Binary search for insertion index
  function findInsertionIndex(array, value) {
    let low = 0, high = array.length;
    while (low < high) {
      const mid = (low + high) >>> 1;
      if (array[mid] < value) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return low;
  }

  // ============================================================
  // 3) GET FINAL BATCH INTERSECTION
  //    For each token:
  //      - union of EXACT MATCH batch set + all prefix match sets
  //    Then intersect across tokens
  // ============================================================
  function getFinalBatchIntersection(tokens) {
    let runningSet = null;

    for (const token of tokens) {
      const matchSet = new Set();

      // Exact match
      const exactIdx = exactMatchIndex(token);
      if (exactIdx !== -1) {
        BATCHES[exactIdx].forEach(id => matchSet.add(id));
      }

      // Prefix matches
      const prefixRange = findPrefixRange(token);
      for (let i = prefixRange.start; i < prefixRange.end; i++) {
        BATCHES[i].forEach(id => matchSet.add(id));
      }

      // Intersect with running set (implementing AND logic)
      if (runningSet === null) {
        runningSet = matchSet; // first token
      } else {
        const temp = new Set();
        for (const b of runningSet) {
          if (matchSet.has(b)) {
            temp.add(b);
          }
        }
        runningSet = temp;
      }

      if (!runningSet.size) break; // short circuit if empty
    }

    return runningSet || new Set();
  }

  function exactMatchIndex(word) {
    let low = 0, high = KEYWORDS.length - 1;
    while (low <= high) {
      const mid = (low + high) >>> 1;
      if (KEYWORDS[mid] === word) return mid;
      if (KEYWORDS[mid] < word) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return -1;
  }

  function findPrefixRange(prefix) {
    const startIdx = findInsertionIndex(KEYWORDS, prefix);
    let endIdx = startIdx;
    while (endIdx < KEYWORDS.length && KEYWORDS[endIdx].startsWith(prefix)) {
      endIdx++;
    }
    return { start: startIdx, end: endIdx };
  }

  // ============================================================
  // 4) PROCESS A BATCH
  //    - fetch award_batch_XXX.csv.zip
  //    - parse its .txt to get rowIDs, then load CSV with PapaParse
  //    - build a nice "card" layout for each matched row
  // ============================================================
  async function processBatch(batchId, tokens, maxNeeded) {
    const zipFileName = `award_batch_${String(batchId).padStart(3, '0')}.csv.zip`;
    const response = await fetch(zipFileName);
    if (!response.ok) {
      console.warn('Could not fetch batch file: ' + zipFileName);
      return 0;
    }
    const arrayBuffer = await response.arrayBuffer();
    const jsZip = new JSZip();
    const batchZip = await jsZip.loadAsync(arrayBuffer);

    // The zip should contain:
    //   award_batch_XXX.csv
    //   award_batch_XXX_reverse_index.txt
    const reverseIndexName  = `award_batch_${String(batchId).padStart(3, '0')}_reverse_index.txt`;
    const csvFileName       = `award_batch_${String(batchId).padStart(3, '0')}.csv`;

    if (!batchZip.file(reverseIndexName) || !batchZip.file(csvFileName)) {
      console.warn(`Batch zip missing expected files: ${reverseIndexName}, ${csvFileName}`);
      return 0;
    }

    const reverseIndexText = await batchZip.file(reverseIndexName).async('string');
    // Collect rowIDs that match ANY of the user tokens in EXACT or PREFIX form
    const rowIDs = getMatchingRowsInBatch(reverseIndexText, tokens);

    if (!rowIDs.size) {
      return 0; // no matches in this batch
    }

    // Now load the CSV
    const csvData = await batchZip.file(csvFileName).async('string');
    // Parse it with Papa Parse
    const parseResult = Papa.parse(csvData, {
      header: true,
      skipEmptyLines: false,
      dynamicTyping: false
    });

    let displayed = 0;
    for (const rowId of rowIDs) {
      // IMPORTANT: preserve original offset => rowId-1
      if (rowId - 1 >= 0 && rowId - 1 < parseResult.data.length) {
        const rowObject = parseResult.data[rowId - 1];
        // Build the UI block for this row
        const htmlBlock = buildResultItem(rowObject);

        // Append directly to container
        $('#resultsContainer').append(htmlBlock);

        // Add to total if award_amount is present
        const amt = parseFloat(rowObject.award_amount || '0');
        if (!isNaN(amt)) {
          totalAwardAmount += amt;
        }

        displayed++;
        if (displayed >= maxNeeded) break;
      }
    }

    // Attach event handlers for "Read more" links and EIN collapses
    // We do this after appending all rows from this batch.
    initDynamicEventHandlers();

    return displayed;
  }

  function getMatchingRowsInBatch(reverseIndexText, tokens) {
    // Parse the batch-level reverse index:
    //   keyword:row_id1,row_id2,...
    const batchIndexMap = new Map();
    const lines = reverseIndexText.split(/\r?\n/);
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      const parts = trimmed.split(':');
      if (parts.length !== 2) continue;
      const kw = parts[0];
      const rowString = parts[1];
      const rowIds = rowString.split(',').map(x => parseInt(x, 10)).filter(n => !isNaN(n));
      batchIndexMap.set(kw, rowIds);
    }

    // For each user token, do EXACT + PREFIX union, then AND across tokens
    let finalSet = null;
    for (const token of tokens) {
      const rowSetForToken = new Set();

      // EXACT
      if (batchIndexMap.has(token)) {
        batchIndexMap.get(token).forEach(r => rowSetForToken.add(r));
      }

      // PREFIX
      for (const [kw, rowIds] of batchIndexMap.entries()) {
        if (kw.startsWith(token) && kw !== token) {
          rowIds.forEach(r => rowSetForToken.add(r));
        }
      }

      // AND with finalSet
      if (finalSet === null) {
        finalSet = rowSetForToken;
      } else {
        const temp = new Set();
        for (const r of finalSet) {
          if (rowSetForToken.has(r)) {
            temp.add(r);
          }
        }
        finalSet = temp;
      }

      if (!finalSet.size) break; // short circuit if empty
    }
    return finalSet || new Set();
  }

  // Helper to build the HTML snippet for a single row
  function buildResultItem(row) {
    const recipientName = row.recipient_uei_name || '';
    const recipientUEI  = row.recipient_uei || '';
    const awardID       = row.generated_unique_award_id || '';
    const endDate       = row.period_of_performance_current_end_date || '';
    const awardAmount   = row.award_amount || '0';
    const fundingAgencyTop = row.funding_toptier_agency_name || '';
    const fundingAgencySub = row.funding_subtier_agency_name || '';
    const fullDescription = row.description || '';
    const shortDescriptionHtml = truncatedDescription(fullDescription, 300);

    // possible_eins is a JSON blob
    let einHtml = '';
    let rawEINData = row.possible_eins || '{}';
    let recipientAddr = row.recipient_addr || '';
    try {
      const parsed = JSON.parse(rawEINData);
      // Build listing for each key
      const lines = Object.entries(parsed).map(([einID, data]) => {
        // data.name, data.addr
        return `
          <span class="text-sm opacity-80">${escapeHtml(einID)}</span>
          <strong class="md:col-span-2">${escapeHtml(data.name || '')}</strong>
          <span class="md:col-span-2 mb-4 md:mb-0">${escapeHtml(data.addr || '')}</span>
        `;
      }).join('');
      einHtml = `
        <div class="p-4 grid grid-cols-1 md:grid-cols-5 gap-x-2 gap-y-1 md:gap-y-1.5 text-sm">
          <div class="md:col-span-5 text-sm pt-2 pb-2 mb-1 border-b border-gray-200"><strong>Recipient address</strong></div>
          <span class="hidden md:block">&nbsp;</span>
          <span class="md:col-span-2">${escapeHtml(recipientName)}</span>
          <span class="md:col-span-2 text-sm opacity-80">${escapeHtml(recipientAddr)}</span>
          <div class="md:col-span-5 text-sm pt-2 pb-2 mb-1 border-b border-gray-200"><strong>Possible EINs</strong></div>
          ${lines}
        </div>
      `;
    } catch(e) {
      einHtml = `<div class="md:col-span-5">(Could not parse possible EINs)</div>`;
    }

    // The card layout
    return `
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 bg-white border border-gray-200 rounded p-4">
        <div class="flex flex-col gap-2">
          <div>
            <span class="text-sm opacity-80">Recipient</span>
            <div class="font-bold text-[15px]">${escapeHtml(recipientName)}</div>
            <div class="text-sm opacity-80"><abbr title="Unique Entity Identifier">UEI</abbr>: ${escapeHtml(recipientUEI)}</div>
          </div>

          <div>
            <span class="text-sm opacity-80">Amount</span>
            <div class="text-base font-bold text-red-500">${formatCurrency(awardAmount)}</div>
          </div>
        </div>
        <div class="flex flex-col gap-2">
          <div>
            <span class="text-sm opacity-80">Awarded by</span>
            <div class="font-bold text-[15px]">${escapeHtml(fundingAgencyTop)} : ${escapeHtml(fundingAgencySub)}</div>
          </div>

          <div>
            <span class="text-sm opacity-80">Ends</span>
            <div class="text-sm">${escapeHtml(endDate)}</div>
          </div>
        </div>

        <div class="md:col-span-2">
          <span class="text-sm opacity-80">Description</span>
          <div class="text-sm">${truncatedDescription(fullDescription, 300)}</div>
        </div>

        <div class="md:col-span-2 bg-gray-100/50 border-t border-gray-200 -mx-4 -mb-4">
          <button class="einToggle font-semibold text-blue-500 text-sm bg-transparent border-0 py-2 px-4">Show possible matching 501(c)(3) EINs</button>
          <div class="einSection" style="display:none;" class="p-4">
          <div class="test">${einHtml}</div>
          </div>
        </div>
      </div>
    `;
  }

  // Creates a truncated description with "Read more" link if beyond a threshold
  function truncatedDescription(desc, limit) {
    if (desc.length <= limit) {
      // No need to truncate
      return `<div class="descriptionShort capitalize">${escapeHtml(desc)}</div>`;
    }
    // Truncate
    const shortText = desc.substring(0, limit);
    const remainder = desc.substring(limit);
    return `
      <div class="descriptionShort">
        ${escapeHtml(shortText)}...
        <a href="#" class="readMoreLink">Read more</a>
        <span class="descriptionFull" style="display:none;">
          ${escapeHtml(remainder)}
        </span>
      </div>
    `;
  }

  // After building new rows, attach click events so they work
  function initDynamicEventHandlers() {
    // Expand full description text
    $('.readMoreLink').off('click').on('click', function(e) {
      e.preventDefault();
      const $link = $(this);
      const $fullDesc = $link.next('.descriptionFull');
      $fullDesc.show();
      // Remove the "Read more" link or hide it
      $link.hide();
    });

    // Toggle EIN section
    $('.einToggle').off('click').on('click', function() {
      const $toggle = $(this);
      const $section = $toggle.next('.einSection');
      $section.slideToggle(200); // jQuery animate
    });
  }

  // Utility: format as currency
  function formatCurrency(numOrString) {
    const val = parseFloat(numOrString) || 0;
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(val);
  }

  // Simple HTML escaping
  function escapeHtml(str) {
    if (!str) return '';
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }
</script>
