---
layout: default
title: Charity graph - multi-root BFS & taxpayer totals
---

<!-- jQuery for convenience -->
<script src="jquery.min.js"></script>

<!-- Viz.js (core + full render) -->
<script src="viz.js"></script>
<script src="full.render.js"></script>

<!-- svg-pan-zoom for panning/zooming the resulting SVG -->
<script src="svg-pan-zoom.min.js"></script>

<!-- JSZip for reading the zipped CSVs -->
<script src="jszip.min.js"></script>

<!-- Papa Parse for CSV parsing -->
<script src="papaparse.min.js"></script>

<style>
  #activeEINs, #activeFilters {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5em;
  }

  #graph-container {
    overflow: hidden; /* Hide scrollbars */
  }
</style>

<div id="topbar" class="">
  <div id="explanation">
    <h1 class="mb-1">Charity graph</h1>
    <!-- If custom_graph is present, we show "title" or "Displaying exact graph." below -->
    <p id="instructions" class="opacity-80 mb-0 text-[15px]">
      <!-- Will be dynamically set in parseQueryParams() -->
    </p>
    <script>
      const urlParams = new URLSearchParams(window.location.search);
      const returnUrl = urlParams.get('return_url');
      if (returnUrl) {
        document.write(`<div class="mt-1 mb-2"><button class="frameless" onclick="window.location.href='${returnUrl}'">&larr; Back to officer search</button></div>`);
      }
    </script>
    
    <!-- "How it works" toggle is BFS-only -->
    <button class="frameless mb-2 text-base bfs-only" id="howItWorksBtn">How it works</button>
    <div class="h-[0px] overflow-hidden transition-all duration-200 bfs-only" id="howItWorksList">
      <div class="p-4 border border-gray-200 rounded-md bg-white">
        <h3 class="mt-0">How it works</h3>
        <ol class="!list-decimal space-y-1 text-sm pl-4">
          <li>We filter charities by user-specified EINs + any keywords. EINs are always included, everything else must match at least one keyword <em>unless</em> no keywords are set (then all are included).</li>
          <li>We pick the BFS root from the largest-<code>receipt_amt</code> EIN (if any exist), otherwise the largest from the filtered set. If that BFS yields fewer than 5 nodes, we pick the next-largest unvisited charity in the filtered set, BFS again, and so on, until the subgraph has 5 or more nodes or we run out.</li>
          <li>We always include all user-specified EINs plus direct edges among them. Node labels highlight <strong>Taxpayer Funds Received</strong> from <code>govt_amt</code>, and we sum that for the final subgraph.</li>
        </ol>
      </div>
    </div>
  </div>

  <!-- BFS controls are BFS-only -->
  <div id="controls" class="mt-2 mb-4 flex flex-col @xl:items-start @xl:justify-between @xl:flex-row gap-4 bfs-only">
    <!-- EIN Input & Add Button -->
    <div class="relative flex flex-col gap-2 max-w-lg">
      {% include input.html 
        label="Add EIN(s)" 
        id="einInput" 
        placeholder="XX-XXXXXXX or 9 digits" 
        buttonLabel="Add EIN" 
        buttonId="addEinBtn" 
        actions="<button id='clearEINsBtn' class='frameless'>Clear EINs</button>"
      %}

      <div id="activeEINs"></div>
    </div>

    <div class="relative flex flex-col gap-2 max-w-lg">
      {% include input.html 
        label="Add keyword" 
        id="keywordInput" 
        placeholder="Keyword or phrase..." 
        buttonLabel="Add" 
        buttonId="addFilterBtn"
        actions="<button id='clearFiltersBtn' class='frameless'>Clear keywords</button>"
      %}

      <div id="activeFilters"></div>
    </div>

    <div class="flex-1 text-right flex flex-row-reverse md:flex-col items-end justify-between md:justify-end gap-1 md:self-end">
      <!-- <button id="generateBtn">Generate Graph</button> -->
      <button id="downloadBtn" class="frameless" style="display: none;">
        <span class="flex items-center gap-1 text-sm text-gray-500 font-semibold">
          <img src="/assets/images/download.svg" class="size-5" alt="Download SVG">
          Download SVG
        </span>
      </button>
      <div id="status" class=""></div>
    </div>
  </div>
</div>

<div id="excluded-info" class="-mx-4 md:mx-0 mb-4 px-3 pt-3 pb-2 flex gap-4 md:gap-8 md:rounded border-y md:border-x border-gray-200 bg-white" style="display: none;">
  {% include stat.html label="501(c)(3)s <em>not</em> displayed" valueId="excluded501" %}
  {% include stat.html label="Grants <em>not</em> displayed" valueId="excludedGrants" %}
  {% include stat.html label="<strong class='font-semibold'>Taxpayer total in subgraph</strong>" labelColor="text-red opacity-100" valueId="taxpayerTotal" %}
</div>

<div class="relative flex-1 -mx-4 md:mx-0 min-h-[75vh]">
  <!-- Search -->
  <div class="absolute top-4 right-4 z-10">
    <div class="relative">
      <input 
        type="text" 
        id="searchInput"
        class="w-64 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent"
        placeholder="Search nodes..."
      >
      <div id="searchResults" class="absolute w-full mt-1 bg-white border border-gray-200 rounded-md shadow-lg hidden">
        <!-- Results will be populated here -->
      </div>
    </div>
  </div>

  <!-- Legend -->
  <div class="absolute top-4 left-4 z-10 bg-white p-3 rounded-md shadow-md border border-gray-200">
    <div class="text-sm font-medium mb-2">Legend</div>
    <div class="space-y-2">
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 bg-red-100 border-2 border-red-600"></div>
        <span class="text-sm">High taxpayer funds (>$10M)</span>
      </div>
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 bg-amber-100 border-2 border-amber-600"></div>
        <span class="text-sm">Medium taxpayer funds (>$1M)</span>
      </div>
      <div class="flex items-center gap-2">
        <div class="w-4 h-4 bg-gray-100 border-2 border-gray-400"></div>
        <span class="text-sm">Low/No taxpayer funds</span>
      </div>
    </div>
  </div>

  <!-- Zoom Controls -->
  <div class="absolute bottom-4 right-4 z-10 bg-white p-2 rounded-md shadow-md border border-gray-200">
    <div class="flex gap-2">
      <button id="zoomIn" class="p-2 hover:bg-gray-100 rounded">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"/>
        </svg>
      </button>
      <button id="zoomOut" class="p-2 hover:bg-gray-100 rounded">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 12H4"/>
        </svg>
      </button>
      <button id="zoomFit" class="p-2 hover:bg-gray-100 rounded">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-5V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 4h-4m4 0l-5-5"/>
        </svg>
      </button>
    </div>
  </div>

  <!-- Graph Container -->
  <div id="graph-container" class="absolute inset-0 border-y md:border-x border-gray-200 md:rounded bg-white">
    <svg id="graph"></svg>
  </div>
</div>

<!-- Add D3.js -->
<script src="https://d3js.org/d3.v7.min.js"></script>

<script>
  const BFS_CAP = 20;

  // Full data from CSV
  let charities = {};             // EIN -> { name, receipt_amt, govt_amt, contrib_amt, grant_amt }
  let edgeAccumulator = {};       // "filer~grantee" -> totalGrant
  let totalCharitiesCount = 0;    // total charities read
  let totalGrantsCount = 0;       // total edges read from CSV

  // Filter state
  let activeEINs = [];
  let activeKeywords = [];

  // BFS / data-ready
  let dataReady = false;
  let panZoomInstance = null;

  // Custom graph state
  let customGraphEdges = null;  // array of objects { filer, grantee, amt }
  let customTitle = null;       // optional custom title from the query param

  // Add this with other global variables at the top
  let simulation = null;

  $(document).ready(function() {

    // Parse query params first
    parseQueryParams();

    // Load data once
    loadData().then(() => {
      dataReady = true;
      $('#status').text('Data loaded.').css('color', 'black');
      // Generate graph right away (which will respect BFS or custom logic)
      generateGraph();
    }).catch(err => {
      console.error(err);
      $('#status').text('Failed to load data.').css('color', 'red');
    });

    // EIN handling
    $('#addEinBtn').on('click', addEINFromInput);
    $('#einInput').on('keypress', e => {
      if (e.key === 'Enter') addEINFromInput();
    });
    $('#clearEINsBtn').on('click', () => {
      activeEINs = [];
      renderActiveEINs();
      updateQueryParams();
      generateGraph();
    });

    // Keywords
    $('#addFilterBtn').on('click', addKeywordFromInput);
    $('#keywordInput').on('keypress', e => {
      if (e.key === 'Enter') addKeywordFromInput();
    });
    $('#clearFiltersBtn').on('click', () => {
      activeKeywords = [];
      renderActiveKeywords();
      updateQueryParams();
      generateGraph();
    });

    // Download SVG
    $('#downloadBtn').on('click', downloadSVG);

    // Expand/collapse "How it works" (BFS-only)
    $('#howItWorksBtn').on('click', function() {
      const $list = $('#howItWorksList');
      const $btn = $(this);

      if ($list.height() === 0) {
        // Expand
        $list.css('height', 'auto');
        const autoHeight = $list.height();
        $list.height(0);
        $list.height(autoHeight);
        $btn.text('Hide details');
      } else {
        // Collapse
        $list.height(0);
        $btn.text('How it works');
      }
    });
  });

  /**
   * Parse query parameters:
   * - If custom_graph is present, parse it, store in customGraphEdges; ignore other params except for title.
   * - Otherwise, parse eins/keywords in the BFS usage scenario.
   * Also sets the instructions text, and shows/hides BFS elements accordingly.
   */
  function parseQueryParams() {
    const params = new URLSearchParams(window.location.search);
    customTitle = params.get('title') || null;

    const customParam = params.get('custom_graph');
    if (customParam) {
      // We are in custom-graph mode
      const trimmed = customParam.replace(/;+$/, '');
      const segments = trimmed.split(';');
      let edgeList = [];

      segments.forEach(s => {
        const parts = s.split(',');
        if (parts.length !== 3) return; // skip if malformed
        let [filer, grantee, amt] = parts.map(x => x.trim());
        // Remove dashes/spaces from EINS
        filer = filer.replace(/[-\s]/g, '');
        grantee = grantee.replace(/[-\s]/g, '');
        const num = parseInt(amt, 10);
        if (!isNaN(num)) {
          edgeList.push({ filer, grantee, amt: num });
        }
      });
      customGraphEdges = edgeList;

      // BFS controls are hidden
      $('.bfs-only').hide();
      // Taxpayer controls are hidden
      $('#excluded-info').hide();

      // Show instructions
      if (customTitle) {
        const addendum = `<br/><br/><p><strong>NOTE:</strong> Funding is fungible, meaning USAID dollars do not directly flow into these NGOs in a literal sense. Instead, the money moves through multiple layers, with various entities handling and redistributing it.</p>

<p>Rather than focusing solely on individual grants or making definitive statements for how NGOs benefit from USAID, it's more important recognize the broader pattern of funding distribution and influence, and getting rid of the layers of inaccountability.</p>`

        $('#instructions').html('Displaying <strong>' + customTitle + `</strong>${addendum}`);
      } else {
        $('#instructions').text(`Displaying exact graph.${addendum}`);
      }
    } else {
      // BFS scenario: parse EINS, keywords normally
      const einParam = params.get('eins');
      if (einParam) {
        let list = einParam.split(',');
        list.forEach(e => {
          let v = e.replace(/[-\s]/g, '');
          if (/^\d{9}$/.test(v)) {
            if (!activeEINs.includes(v)) {
              activeEINs.push(v);
            }
          }
        });
      }
      const kwParam = params.get('keywords');
      if (kwParam) {
        let kws = kwParam.split(',');
        kws.forEach(k => {
          k = k.trim().toLowerCase();
          if (k && !activeKeywords.includes(k)) {
            activeKeywords.push(k);
          }
        });
      }

      // BFS controls visible
      $('.bfs-only').show();

      // Instructions text for BFS scenario
      $('#instructions').text(
        'Use the search and keywords to filter charities, then BFS expansion is performed automatically.'
      );

      // Render them
      renderActiveEINs();
      renderActiveKeywords();
    }
  }

  /**
   * Update the query parameters to reflect the current activeEINs and activeKeywords.
   * This only applies if we are not in custom-graph mode.
   */
  function updateQueryParams() {
    if (customGraphEdges) {
      // Do nothing if custom_graph is present
      return;
    }
    const params = new URLSearchParams();
    if (activeEINs.length > 0) {
      params.set('eins', activeEINs.join(','));
    }
    if (activeKeywords.length > 0) {
      params.set('keywords', activeKeywords.join(','));
    }
    const newUrl = window.location.pathname + '?' + params.toString();
    window.history.replaceState({}, '', newUrl);
  }

  /**
   * Load charities + grants from the CSV zips.
   */
  async function loadData() {
    $('#status').html('<span class="flex items-center text-sm"><img src="/assets/images/loading.svg" class="size-6" alt="Loading..."> Loading data...</span>');

    // 1) charities
    const charitiesZipBuf = await fetch('charities.csv.zip').then(r => r.arrayBuffer());
    const charitiesZip = await JSZip.loadAsync(charitiesZipBuf);
    const charitiesCsvString = await charitiesZip.file('charities_truncated.csv').async('string');

    await new Promise((resolve, reject) => {
      Papa.parse(charitiesCsvString, {
        header: true,
        skipEmptyLines: true,
        complete: results => {
          results.data.forEach(row => {
            const ein = (row['filer_ein'] || '').trim();
            if (!ein) return;
            let rAmt = parseInt((row['receipt_amt'] || '0').trim(), 10);
            if (isNaN(rAmt)) rAmt = 0;
            charities[ein] = {
              name: (row['filer_name'] || '').trim(),
              xml_name: row['xml_name'],
              receipt_amt: rAmt,
              govt_amt: parseInt((row['govt_amt'] || '0').trim(), 10) || 0,
              contrib_amt: parseInt((row['contrib_amt'] || '0').trim(), 10) || 0,
              grant_amt: 0 // will accumulate below
            };
          });
          totalCharitiesCount = Object.keys(charities).length;
          resolve();
        },
        error: err => reject(err)
      });
    });

    // 2) grants
    const grantsZipBuf = await fetch('grants.csv.zip').then(r => r.arrayBuffer());
    const grantsZip = await JSZip.loadAsync(grantsZipBuf);
    const grantsCsvString = await grantsZip.file('grants_truncated.csv').async('string');

    await new Promise((resolve, reject) => {
      Papa.parse(grantsCsvString, {
        header: true,
        skipEmptyLines: true,
        complete: results => {
          let localEdges = {};
          let count = 0;
          results.data.forEach(row => {
            const filer = (row['filer_ein'] || '').trim();
            const grantee = (row['grant_ein'] || '').trim();
            let amt = parseInt((row['grant_amt'] || '0').trim(), 10);
            if (isNaN(amt)) amt = 0;
            count++;
            if (charities[filer] && charities[grantee]) {
              const key = filer + '~' + grantee;
              if (!localEdges[key]) localEdges[key] = 0;
              localEdges[key] += amt;
              charities[filer].grant_amt += amt;
            }
          });
          edgeAccumulator = localEdges;
          totalGrantsCount = count;
          resolve();
        },
        error: err => reject(err)
      });
    });
  }

  /**
   * The main graph-generation entry point.
   * - If custom_graph is present, we parse and render that directly.
   * - Else, we do BFS logic based on activeEINs & keywords.
   */
  function generateGraph() {
    if (!dataReady) {
      alert("Data not loaded yet. Please wait.");
      return;
    }

    // Clear old graph
    $('#graph-container').empty().append('<svg id="graph"></svg>');
    $('#excluded-info').hide();

    $('#status').text('Generating...').css('color', 'red');

    // Get container dimensions
    const container = document.getElementById('graph-container');
    const width = container.offsetWidth;
    const height = container.offsetHeight || window.innerHeight * 0.7;

    // Create SVG
    const svg = d3.select('#graph')
      .attr('width', '100%')
      .attr('height', '100%')
      .style('display', 'block');

    // Add zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });

    svg.call(zoom);

    // Main group for zoom/pan
    const g = svg.append('g');

    // Get nodes and edges based on mode
    let { nodes, edges } = customGraphEdges 
      ? getCustomGraphData() 
      : getBFSGraphData();

    // Add initial positions before starting the simulation
    nodes.forEach((node, i) => {
      const angle = (i / nodes.length) * 2 * Math.PI;
      const radius = Math.sqrt(nodes.length) * 100;
      node.x = width/2 + radius * Math.cos(angle);
      node.y = height/2 + radius * Math.sin(angle);
    });

    // Create force simulation with adjusted parameters
    const forceParams = getForceParameters(nodes, width, height);

    simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(edges)
        .id(d => d.id)
        .distance(forceParams.linkDistance))
      .force('charge', d3.forceManyBody()
        .strength(forceParams.charge)
        .distanceMin(200)
        .distanceMax(forceParams.linkDistance * 2))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius(forceParams.collisionRadius))
      .force('x', d3.forceX(width / 2).strength(forceParams.xStrength))
      .force('y', d3.forceY(height / 2).strength(forceParams.yStrength))
      // Reduce the simulation's energy to prevent excessive movement
      .alpha(0.5) // Start with less energy
      .alphaDecay(0.02) // Faster decay
      .velocityDecay(0.4) // More damping
      .restart();

    // Add arrow marker definition
    svg.append('defs').selectAll('marker')
      .data(['arrow'])
      .join('marker')
      .attr('id', 'arrow')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 20)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', '#94A3B8');

    // Create curved links with labels
    const linkGroup = g.append('g').attr('class', 'links');
    const linkElements = linkGroup.selectAll('g')
      .data(edges)
      .join('g')
      .attr('class', 'link-group');

    const links = linkElements.append('path')
      .attr('class', 'link')
      .attr('stroke', '#94A3B8')
      .attr('stroke-width', 2)
      .attr('fill', 'none')
      .attr('marker-end', 'url(#arrow)');

    // Add invisible wider path for easier hovering
    linkElements.append('path')
      .attr('class', 'link-hover')
      .attr('stroke', 'transparent')
      .attr('stroke-width', 20) // Wider than before for easier hovering
      .attr('fill', 'none')
      .style('cursor', 'pointer')
      .on('mouseover', function(event, d) {
        // Highlight this link
        d3.select(this.parentNode).select('.link')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3);
        // Highlight connected nodes
        nodeElements
          .filter(n => n.id === d.source.id || n.id === d.target.id)
          .select('rect')
          .attr('stroke', '#2563EB')
          .attr('stroke-width', 3);
      })
      .on('mouseout', function(event, d) {
        // Reset link style
        d3.select(this.parentNode).select('.link')
          .attr('stroke', '#94A3B8')
          .attr('stroke-width', 2);
        // Reset node styles
        nodeElements.select('rect')
          .attr('stroke', n => getNodeStroke(n))
          .attr('stroke-width', n => isUserEin(n.id) ? 3 : 1);
      });

    // Move link labels to a separate group that's rendered on top of everything
    const labelGroup = g.append('g').attr('class', 'label-group');
    const linkLabels = labelGroup.selectAll('text')
      .data(edges)
      .join('text')
      .attr('class', 'link-label')
      .attr('dy', -10)
      .attr('text-anchor', 'middle')
      .attr('fill', '#64748B')
      .attr('font-size', '12px')
      .attr('paint-order', 'stroke') // Add white outline to text
      .attr('stroke', 'white')
      .attr('stroke-width', '3px')
      .text(d => `$${formatNumber(d.amt)}`);

    // Create nodes
    const nodeGroup = g.append('g').attr('class', 'nodes');
    const nodeElements = nodeGroup.selectAll('g')
      .data(nodes)
      .join('g')
      .attr('data-id', d => d.id)
      .attr('class', 'node')
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended));

    // Node rectangles
    nodeElements.append('rect')
      .attr('rx', 4)
      .attr('ry', 4)
      .attr('width', d => getNodeWidth(d))
      .attr('height', d => getNodeHeight(d))
      .attr('fill', d => getNodeColor(d))
      .attr('stroke', d => getNodeStroke(d))
      .attr('stroke-width', d => isUserEin(d.id) ? 3 : 1);

    // Node content (name, EIN, amounts)
    nodeElements.each(function(d) {
      const node = d3.select(this);
      const charity = charities[d.id];
      const padding = 10;
      let y = padding;

      // Name
      node.append('text')
        .attr('x', padding)
        .attr('y', y += 20)
        .attr('fill', '#000')
        .attr('font-weight', 'bold')
        .text(charity.name);

      // EIN
      node.append('text')
        .attr('x', padding)
        .attr('y', y += 20)
        .attr('fill', '#64748B')
        .text(`EIN: ${d.id.slice(0,2)}-${d.id.slice(2)}`);

      // Amounts
      const amounts = [
        ['Gross receipts', charity.receipt_amt],
        ['Contributions', charity.contrib_amt],
        ['Grants given', charity.grant_amt],
        ['Taxpayer funds', charity.govt_amt]
      ];

      amounts.forEach(([label, amount]) => {
        node.append('text')
          .attr('x', padding)
          .attr('y', y += 20)
          .attr('fill', label === 'Taxpayer funds' && amount > 0 ? '#DC2626' : '#000')
          .attr('font-weight', label === 'Taxpayer funds' ? 'bold' : 'normal')
          .text(`${label}: $${formatNumber(amount)}`);
      });
    });

    // Node hover effects
    nodeElements
      .on('mouseover', function(event, d) {
        // Highlight connected links
        linkElements.each(function(l) {
          if (l.source.id === d.id || l.target.id === d.id) {
            d3.select(this).select('.link')
              .attr('stroke', '#2563EB')
              .attr('stroke-width', 3);
          }
        });
      })
      .on('mouseout', function() {
        linkElements.selectAll('.link')
          .attr('stroke', '#94A3B8')
          .attr('stroke-width', 2);
      });

    // Update positions on simulation tick
    simulation.on('tick', () => {
      // Update node positions with boundary constraints
      nodeElements.attr('transform', d => {
        const nodeWidth = getNodeWidth(d);
        const nodeHeight = getNodeHeight(d);
        const padding = 100;
        
        d.x = Math.max(forceParams.bounds.left + nodeWidth/2, 
          Math.min(forceParams.bounds.right - nodeWidth/2, d.x || 0));
        d.y = Math.max(forceParams.bounds.top + nodeHeight/2, 
          Math.min(forceParams.bounds.bottom - nodeHeight/2, d.y || 0));
        
        return `translate(${d.x - nodeWidth/2},${d.y - nodeHeight/2})`;
      });

      // Update link paths
      links.attr('d', d => {
        const sourceNode = d3.select(`g[data-id="${d.source.id}"]`).node();
        const targetNode = d3.select(`g[data-id="${d.target.id}"]`).node();
        
        if (!sourceNode || !targetNode) return '';
        
        const sourceBox = sourceNode.getBBox();
        const targetBox = targetNode.getBBox();
        
        const sourceX = d.source.x || 0;
        const sourceY = d.source.y || 0;
        const targetX = d.target.x || 0;
        const targetY = d.target.y || 0;
        
        // Calculate edge points
        const dx = targetX - sourceX;
        const dy = targetY - sourceY;
        const angle = Math.atan2(dy, dx);
        
        // Offset from node edges
        const sourceW = sourceBox.width;
        const sourceH = sourceBox.height;
        const targetW = targetBox.width;
        const targetH = targetBox.height;
        
        // Calculate where the line should start/end at node boundaries
        const sourcePoint = {
          x: sourceX + (Math.cos(angle) * sourceW/2),
          y: sourceY + (Math.sin(angle) * sourceH/2)
        };
        
        const targetPoint = {
          x: targetX - (Math.cos(angle) * targetW/2),
          y: targetY - (Math.sin(angle) * targetH/2)
        };

        // Add variation to the curve based on the source and target positions
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Create a unique curve for each path based on its position
        const curveOffset = (sourceX + targetX + sourceY + targetY) % 200 - 100;
        const curvature = Math.min(distance / 2, 200) + curveOffset;
        
        // Calculate control point offset perpendicular to the line
        const mx = (sourcePoint.x + targetPoint.x) / 2;
        const my = (sourcePoint.y + targetPoint.y) / 2;
        
        // Perpendicular vector
        const px = -dy / distance;
        const py = dx / distance;
        
        // Control point
        const cx = mx + px * curvature;
        const cy = my + py * curvature;
        
        return `M${sourcePoint.x},${sourcePoint.y} Q${cx},${cy} ${targetPoint.x},${targetPoint.y}`;
      });

      // Update hover paths
      linkElements.select('.link-hover')
        .attr('d', function() {
          return d3.select(this.parentNode).select('.link').attr('d');
        });

      // Update link labels
      linkLabels.attr('transform', function(d) {
        const sourceNode = d3.select(`g[data-id="${d.source.id}"]`).node();
        const targetNode = d3.select(`g[data-id="${d.target.id}"]`).node();
        
        if (!sourceNode || !targetNode) return '';
        
        const sourceX = d.source.x || 0;
        const sourceY = d.source.y || 0;
        const targetX = d.target.x || 0;
        const targetY = d.target.y || 0;
        
        // Calculate midpoint with offset
        const dx = targetX - sourceX;
        const dy = targetY - sourceY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Create unique offset for each label
        const curveOffset = (sourceX + targetX + sourceY + targetY) % 200 - 100;
        const curvature = Math.min(distance / 2, 200) + curveOffset;
        
        // Perpendicular vector
        const px = -dy / distance;
        const py = dx / distance;
        
        // Position label at offset midpoint
        const mx = (sourceX + targetX) / 2 + px * curvature * 0.5;
        const my = (sourceY + targetY) / 2 + py * curvature * 0.5;
        
        return `translate(${mx},${my})`;
      });
    });

    // Handle zoom controls
    document.getElementById('zoomIn').onclick = () => {
      svg.transition().duration(300).call(zoom.scaleBy, 1.3);
    };

    document.getElementById('zoomOut').onclick = () => {
      svg.transition().duration(300).call(zoom.scaleBy, 0.7);
    };

    document.getElementById('zoomFit').onclick = () => {
      const bounds = g.node().getBBox();
      const dx = bounds.x;
      const dy = bounds.y;
      const scale = 0.4 / Math.max( // Reduced initial scale for larger graphs
        bounds.width / width,
        bounds.height / height
      );

      svg.transition()
        .duration(750)
        .call(zoom.transform,
          d3.zoomIdentity
            .translate(width/2, height/2)
            .scale(scale)
            .translate(-dx-bounds.width/2, -dy-bounds.height/2));
    };

    // Also update the initial zoom to account for the larger bounds
    setTimeout(() => {
      const bounds = g.node().getBBox();
      const dx = bounds.x;
      const dy = bounds.y;
      const scale = 0.4 / Math.max( // Reduced initial scale for larger graphs
        bounds.width / width,
        bounds.height / height
      );

      svg.transition()
        .duration(750)
        .call(zoom.transform,
          d3.zoomIdentity
            .translate(width/2, height/2)
            .scale(scale)
            .translate(-dx-bounds.width/2, -dy-bounds.height/2));
    }, 1000);

    // Update status
    $('#status').html(`<span class="text-sm text-green font-semibold">${nodes.length} charities displayed</span>`);
    $('#downloadBtn').show();
  }

  // Helper functions for graph data preparation
  function getCustomGraphData() {
    const nodes = new Set();
    customGraphEdges.forEach(e => {
      if (charities[e.filer]) nodes.add(e.filer);
      if (charities[e.grantee]) nodes.add(e.grantee);
    });

    return {
      nodes: Array.from(nodes).map(id => ({ id })),
      edges: customGraphEdges.map(e => ({
        source: e.filer,
        target: e.grantee,
        amt: e.amt
      }))
    };
  }

  function getBFSGraphData() {
    const { filteredCharities, filteredEdges } = buildFilteredData();
    const visitedSet = multiRootBFS(filteredCharities, buildAdjacency(filteredEdges));
    
    // Force include user EINS
    activeEINs.forEach(ein => {
      if (filteredCharities[ein]) visitedSet.add(ein);
    });

    // Build final edges
    const edges = [];
    Object.entries(filteredEdges).forEach(([key, amt]) => {
      const [filer, grantee] = key.split('~');
      if (visitedSet.has(filer) && visitedSet.has(grantee)) {
        edges.push({ source: filer, target: grantee, amt });
      }
    });

    return {
      nodes: Array.from(visitedSet).map(id => ({ id })),
      edges
    };
  }

  // Force simulation helpers
  function dragstarted(event, d) {
    if (!event.active && simulation) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragended(event, d) {
    if (!event.active && simulation) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  /**
   * Build a filtered subset of charities + edges (for BFS scenario).
   * - If activeKeywords is non-empty, a charity must match at least one or be in activeEINs.
   * - If no keywords, we include all charities plus the user EINS.
   */
  function buildFilteredData() {
    let filteredCharities = {};
    const hasKeywords = (activeKeywords.length > 0);

    for (const [ein, c] of Object.entries(charities)) {
      if (activeEINs.includes(ein)) {
        // Always keep user-specified EIN
        filteredCharities[ein] = c;
        continue;
      }
      if (hasKeywords) {
        // Must match at least one keyword
        const nm = c.name.toLowerCase();
        const matched = activeKeywords.some(kw => nm.includes(kw));
        if (matched) {
          filteredCharities[ein] = c;
        }
      } else {
        // No keywords => keep everything
        filteredCharities[ein] = c;
      }
    }

    // Filter edges so that both ends are in the filtered set
    let filteredEdges = {};
    for (const [key, amt] of Object.entries(edgeAccumulator)) {
      const [filer, grantee] = key.split('~');
      if (filteredCharities[filer] && filteredCharities[grantee]) {
        filteredEdges[key] = amt;
      }
    }

    return { filteredCharities, filteredEdges };
  }

  /**
   * Build DOT string. 
   */
  function buildDotSource(nodeSet, edgeList, filteredCharities, taxpayerTotal) {
    let dot = `digraph G {
rankdir=LR;
nodesep=0.5;
ranksep=0.5;
node [
  shape=box,
  style="filled",
  fillcolor="#F3F4F6",
  color="#94A3B8",
  fontname="SF Pro, Helvetica, sans-serif",
  fontsize=14,
  margin=0.1,
  penwidth=1
];
edge [
  fontname="SF Pro, Helvetica, sans-serif",
  color="#DADBE7",
  penwidth=2,
  fontsize=11,
  decorate=true,
  labelangle=0,
  labeldistance=2
];
graph [
  fontname="SF Pro, Helvetica, sans-serif",
  splines=spline,
  overlap=false
];
labelloc="t";\n`;

    for (const ein of nodeSet) {
      const c = filteredCharities[ein];
      if (!c) continue; // safety

      let escapedName = c.name.replace(/[&<>"']/g, char => {
        switch (char) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case "'": return '&apos;';
          default: return char;
        }
      });

      // If we are in BFS scenario (customGraphEdges == null), highlight keywords
      if (!customGraphEdges && activeKeywords.length > 0) {
        activeKeywords.forEach(kw => {
          const regex = new RegExp(`(\\s*)(${kw})`, 'gi');
          escapedName = escapedName.replace(regex, '$1<B><FONT COLOR="#2563EB">$2</FONT></B> ').trim();
        });
      }

      const receipts = formatNumber(c.receipt_amt);
      const govt = formatNumber(c.govt_amt);
      const contrib = formatNumber(c.contrib_amt);
      const grants = formatNumber(c.grant_amt);

      const label = `<<TABLE BORDER="0" CELLBORDER="0" CELLSPACING="2" cellpadding="2">
        ${
          c.govt_amt > 10000000 
          ? `<tr><td colspan="4"><table border="0" cellspacing="0" cellpadding="5"><tr><td colspan="2" BGCOLOR="#DC2626">
             <font color="white"><b>🚨🚨🚨 High Taxpayer Funds Alert! 🚨🚨🚨</b></font>
             </td></tr></table></td></tr>` 
          : ''
        }
        <tr><td colspan="4"><table border="0" cellspacing="0" cellpadding="0"><tr><td colspan="4" height="2"></td></tr></table></td></tr>
        <tr><td colspan="3" align="left"><b>${escapedName}</b></td><td>&nbsp;</td></tr>
        <tr><td colspan="3" align="left">EIN: ${ein.slice(0,2)}-${ein.slice(2)}</td><td>&nbsp;</td></tr>
        <tr><td colspan="4">
          <table border="0" cellspacing="0" cellpadding="0"><tr><td colspan="2" bgcolor="#000000" height="2"></td></tr></table>
        </td></tr>
        <tr><td align="left">Gross receipts</td><td>&nbsp;</td><td align="right">$${receipts}</td><td>&nbsp;</td></tr>
        <tr><td align="left">Contributions</td><td>&nbsp;</td><td align="right">$${contrib}</td><td>&nbsp;</td></tr>
        <tr><td align="left">Grants given (visible)</td><td>&nbsp;</td><td align="right">$${grants}</td><td>&nbsp;</td></tr>
        <tr>
          <td colspan="3">
            <table border="0" cellspacing="0" cellpadding="0">
              <tr>
                <td align="left"><font ${c.govt_amt > 0 ? 'color="#DC2626"' : 'color="#000"'}><b>Taxpayer funds</b></font></td>
                <td align="right"><font ${c.govt_amt > 0 ? 'color="#DC2626"' : 'color="#000"'}><b>$${govt}</b></font></td>
              </tr>
            </table>
          </td>
          <td>&nbsp;</td>
        </tr>
      </TABLE>>`;

      // Color logic: highlight user EINS if BFS scenario
      let nodeStyle = '';
      const isUserEin = (!customGraphEdges && activeEINs.includes(ein));
      if (isUserEin) {
        // BFS scenario, user-searched node
        if (c.govt_amt > 10000000) {
          nodeStyle = 'fillcolor="#FEE2E2" color="#DC2626" penwidth=3';
        } else if (c.govt_amt > 1000000) {
          nodeStyle = 'fillcolor="#FEF3C7" color="#D97706" penwidth=3';
        } else {
          // Blue highlight if user-specified but not a high govt amt
          nodeStyle = 'fillcolor="#F3F4F6" color="#2563EB" penwidth=3';
        }
      } else {
        // Normal styling
        if (c.govt_amt > 10000000) {
          nodeStyle = 'fillcolor="#FEE2E2" color="#DC2626"';
        } else if (c.govt_amt > 1000000) {
          nodeStyle = 'fillcolor="#FEF3C7" color="#D97706"';
        } else if (c.govt_amt > 0) {
          nodeStyle = 'fillcolor="#F3F4F6" color="#4B5563"';
        } else {
          nodeStyle = 'fillcolor="#F3F4F6" color="#94A3B8"';
        }
      }

      dot += `  "${ein}" [${nodeStyle}, label=${label}];\n`;
    }

    // Edges
    for (const e of edgeList) {
      const amt = formatNumber(e.amt);
      dot += `  "${e.filer}" -> "${e.grantee}" [label="$${amt}", color="#94A3B8"];\n`;
    }

    dot += `}\n`;
    return dot;
  }

  function formatNumber(x) {
    const n = parseInt(x, 10) || 0;
    return n.toLocaleString('en-US');
  }

  function addEINFromInput() {
    let val = $('#einInput').val().trim();
    val = val.replace(/[-\s]/g, ''); // Remove hyphens and spaces first
    
    if (!/^\d{9}$/.test(val)) {
      alert("EIN must be 9 digits after removing dashes/spaces.");
      return;
    }
    if (!charities[val]) {
      console.warn("EIN not found in charities.csv (still adding).");
    }
    if (!activeEINs.includes(val)) {
      activeEINs.push(val);
    }
    $('#einInput').val('');
    renderActiveEINs();
    updateQueryParams();
    generateGraph();
  }

  function renderActiveEINs() {
    const $c = $('#activeEINs');
    $c.empty();
    $('#clearEINsBtn').toggle(activeEINs.length > 0);

    activeEINs.forEach(ein => {
      const $tag = $('<div class="filter-tag flex items-center gap-0.5 rounded border border-blue bg-blue/10 text-blue rounded-md px-2 py-1 text-xs"></div>');
      const $text = $('<span></span>').text(ein.slice(0,2) + '-' + ein.slice(2));
      const $rm = $('<span class="remove-filter opacity-50 hover:opacity-100 size-5 -my-0.5 -mr-1 cursor-pointer">{% include close.html %}</span>').attr('data-ein', ein);
      $rm.on('click', function() {
        const rem = $(this).attr('data-ein');
        activeEINs = activeEINs.filter(x => x !== rem);
        renderActiveEINs();
        updateQueryParams();
        generateGraph();
      });
      $tag.append($text).append($rm);
      $c.append($tag);
    });
  }

  function addKeywordFromInput() {
    const kw = $('#keywordInput').val().trim();
    if (kw.length > 0) {
      activeKeywords.push(kw.toLowerCase());
      $('#keywordInput').val('');
      renderActiveKeywords();
      updateQueryParams();
      generateGraph();
    }
  }

  function renderActiveKeywords() {
    const $c = $('#activeFilters');
    $c.empty();
    $('#clearFiltersBtn').toggle(activeKeywords.length > 0);

    activeKeywords.forEach(kw => {
      const $tag = $('<div class="filter-tag flex items-center gap-0.5 rounded border border-blue bg-blue/10 text-blue rounded-md px-2 py-1 text-xs"></div>');
      const $text = $('<span></span>').text(kw);
      const $rm = $('<span class="remove-filter opacity-50 hover:opacity-100 size-5 -my-0.5 -mr-1 cursor-pointer">{% include close.html %}</span>').attr('data-kw', kw);
      $rm.on('click', function() {
        const rem = $(this).attr('data-kw');
        activeKeywords = activeKeywords.filter(x => x !== rem);
        renderActiveKeywords();
        updateQueryParams();
        generateGraph();
      });
      $tag.append($text).append($rm);
      $c.append($tag);
    });
  }

  /**
   * Download the currently displayed SVG as a file named "charity_graph.svg".
   */
  function downloadSVG() {
    const svgEl = document.querySelector('#graph-container svg');
    if (!svgEl) {
      alert('No SVG to download yet.');
      return;
    }
    const svgData = new XMLSerializer().serializeToString(svgEl);
    const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = 'charity_graph.svg';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  function buildAdjacency(edges) {
    const fwd = {};
    const rev = {};
    
    Object.entries(edges).forEach(([key, amt]) => {
      const [filer, grantee] = key.split('~');
      
      // Forward adjacency
      if (!fwd[filer]) fwd[filer] = [];
      fwd[filer].push(grantee);
      
      // Reverse adjacency
      if (!rev[grantee]) rev[grantee] = [];
      rev[grantee].push(filer);
    });
    
    return { fwd, rev };
  }

  function multiRootBFS(filteredCharities, adjacency) {
    const visited = new Set();
    const allEINs = Object.keys(filteredCharities);

    // Sort them by descending receipt_amt
    let sortedByReceipt = allEINs.slice().sort((a,b) => {
      return filteredCharities[b].receipt_amt - filteredCharities[a].receipt_amt;
    });

    // If user EINs exist in the filtered set, BFS from the largest among them first
    let hasUserEINsInFiltered = activeEINs.filter(x => allEINs.includes(x));
    if (hasUserEINsInFiltered.length > 0) {
      let largestUserEIN = hasUserEINsInFiltered.reduce((best, cur) => {
        if (!best) return cur;
        const bestAmt = filteredCharities[best].receipt_amt;
        const curAmt = filteredCharities[cur].receipt_amt;
        return (curAmt > bestAmt) ? cur : best;
      }, null);

      bfsFromRoot(largestUserEIN, adjacency, visited);
      sortedByReceipt = sortedByReceipt.filter(x => x !== largestUserEIN);
    }

    // If <5 visited, BFS from next-largest
    let idx = 0;
    while (visited.size < 5 && idx < sortedByReceipt.length) {
      const candidate = sortedByReceipt[idx];
      if (!visited.has(candidate)) {
        bfsFromRoot(candidate, adjacency, visited);
      }
      idx++;
    }

    return visited;
  }

  function bfsFromRoot(root, adjacency, visited) {
    if (!root) return;
    
    // Forward BFS
    let queue = [root];
    const localFwd = new Set();
    while (queue.length > 0 && localFwd.size < BFS_CAP) {
      const curr = queue.shift();
      if (!localFwd.has(curr)) {
        localFwd.add(curr);
        const neighs = adjacency.fwd[curr] || [];
        for (let n of neighs) {
          if (!localFwd.has(n) && localFwd.size < BFS_CAP) {
            queue.push(n);
          }
        }
      }
    }

    // Reverse BFS
    const localRev = new Set();
    queue = [root];
    while (queue.length > 0 && localRev.size < BFS_CAP) {
      const curr = queue.shift();
      if (!localRev.has(curr)) {
        localRev.add(curr);
        const neighs = adjacency.rev[curr] || [];
        for (let n of neighs) {
          if (!localRev.has(n) && localRev.size < BFS_CAP) {
            queue.push(n);
          }
        }
      }
    }

    // Union
    for (let x of localFwd) visited.add(x);
    for (let x of localRev) visited.add(x);
  }

  // Add these helper functions before generateGraph()

  function getNodeWidth(d) {
    const charity = charities[d.id];
    // Base width that will fit the content
    return 300; // Fixed width for now
  }

  function getNodeHeight(d) {
    const charity = charities[d.id];
    // Height based on content (name + EIN + 4 amounts)
    return 140; // Fixed height for now
  }

  function getNodeColor(d) {
    const charity = charities[d.id];
    if (charity.govt_amt > 10000000) return '#FEE2E2'; // red-100
    if (charity.govt_amt > 1000000) return '#FEF3C7';  // amber-100
    return '#F3F4F6'; // gray-100
  }

  function getNodeStroke(d) {
    const charity = charities[d.id];
    if (charity.govt_amt > 10000000) return '#DC2626'; // red-600
    if (charity.govt_amt > 1000000) return '#D97706';  // amber-600
    return '#94A3B8'; // gray-400
  }

  function isUserEin(ein) {
    return activeEINs.includes(ein);
  }

  function formatNumber(x) {
    return (parseInt(x, 10) || 0).toLocaleString('en-US');
  }

  // Update the force simulation parameters to scale with node count
  function getForceParameters(nodes, width, height) {
    const nodeCount = nodes.length;
    
    // Scale up distances and forces based on node count
    const baseDistance = 600;
    const distanceScale = Math.min(2, 1 + (nodeCount / 20)); // Increase up to 2x for large graphs
    
    // Scale the viewport bounds based on node count
    const boundaryScale = Math.min(3, 1 + (nodeCount / 15)); // Increase up to 3x for large graphs
    
    return {
      linkDistance: baseDistance * distanceScale,
      charge: -5000 * distanceScale,
      collisionRadius: 250 * Math.sqrt(distanceScale),
      bounds: {
        left: -width * boundaryScale / 2,
        right: width * boundaryScale,
        top: -height * boundaryScale / 2,
        bottom: height * boundaryScale
      },
      // Reduce force strengths for larger graphs to prevent excessive movement
      centerStrength: 0.02 / Math.sqrt(distanceScale),
      xStrength: 0.01 / Math.sqrt(distanceScale),
      yStrength: 0.01 / Math.sqrt(distanceScale)
    };
  }
</script>
