---
layout: full_width
title: Charity graph - multi-root BFS & taxpayer totals
---

    
<!-- jQuery for convenience -->
<script src="jquery.min.js"></script>

<!-- Viz.js (core + full render) -->
<script src="viz.js"></script>
<script src="full.render.js"></script>

<!-- svg-pan-zoom for panning/zooming the resulting SVG -->
<script src="svg-pan-zoom.min.js"></script>

<!-- JSZip for reading the zipped CSVs -->
<script src="jszip.min.js"></script>

<!-- Papa Parse for CSV parsing -->
<script src="papaparse.min.js"></script>

<style>
  


  #activeEINs, #activeFilters {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5em;
  }


  
  #graph-container {
    overflow: hidden; /* Hide scrollbars */
  }

</style>



<div id="topbar" class="max-w-7xl mx-auto">
  <div id="explanation">
    <h2><abbr title="BFS (Breadth-First Search) is a variation of the standard BFS algorithm where the traversal starts from multiple sources (roots) simultaneously instead of a single source.">Multi-root BFS</abbr> & taxpayer totals</h2>
    <ol class="!list-decimal ml-4 space-y-1 mb-4 text-sm">
      <li>We filter charities by user-specified EINs + any keywords. EINs are always included, everything else must match at least one keyword <em>unless</em> no keywords are set (then all are included).</li>
      <li>We pick the BFS root from the largest-<code>receipt_amt</code> EIN (if any exist), otherwise the largest from the filtered set. If that BFS yields fewer than 5 nodes, we pick the next-largest unvisited charity in the filtered set, BFS again, and so on, until the subgraph has 5 or more nodes or we run out.</li>
      <li>We always include all user-specified EINs plus direct edges among them. Node labels highlight <strong>Taxpayer Funds Received</strong> from <code>govt_amt</code>, and we sum that for the final subgraph.</li>
    </ol>
  </div>
  <div id="controls" class="mb-4 flex flex-col md:items-start md:justify-between md:flex-row gap-4">
    <!-- EIN Input & Add Button -->
     <div class="relative flex flex-col gap-2 max-w-lg">
      {% include input.html 
        label="Add EIN" 
        id="einInput" 
        placeholder="XX-XXXXXXX or 9 digits" 
        buttonLabel="Add EIN" 
        buttonId="addEinBtn" 
        actions="<button id='clearEINsBtn' class='frameless'>Clear EINs</button>"
      %}

      <div id="activeEINs"></div>
    </div>

    <div class="relative flex flex-col gap-2 max-w-lg">
      {% include input.html 
        label="Add keyword" 
        id="keywordInput" 
        placeholder="Keyword or phrase..." 
        buttonLabel="Add" 
        buttonId="addFilterBtn"
        actions="<button id='clearFiltersBtn' class='frameless'>Clear keywords</button>"
      %}

      <div id="activeFilters"></div>
      
    </div>

    
    <div class="flex-1 text-right flex flex-row-reverse md:flex-col items-end justify-between md:justify-end gap-1 md:self-end">
      <!-- <button id="generateBtn">Generate Graph</button> -->
      <button id="downloadBtn" class="frameless" style="display: none;">
        <span class="flex items-center gap-1 text-sm text-gray-500 font-semibold">
          <img src="/assets/images/download.svg" class="size-5" alt="Download SVG">
          Download SVG
        </span>
      </button>
      <div id="status" class=""></div>

    </div>
  </div>
</div>

<div id="excluded-info" class="max-w-7xl -mx-4 md:mx-auto mb-4 px-3 pt-3 pb-2 flex gap-4 md:gap-8 md:rounded border-y md:border-x border-gray-200 bg-white" style="display: none;">

  {% include stat.html label="501(c)(3)s <em>not</em> displayed" valueId="excluded501" %}

  {% include stat.html label="Grants <em>not</em> displayed" valueId="excludedGrants" %}

  {% include stat.html label="<strong>Taxpayer total in subgraph</strong>" labelColor="text-red-500" valueId="taxpayerTotal" %}

</div>

<div id="graph-container" class="flex-1 -mx-4 border-y border-gray-200 bg-white md:min-h-[50vh] flex items-center justify-center">
  <div class="">
    <img src="/assets/images/loading.svg" class="size-12" alt="Loading...">
  </div>
</div>


<script>
  const BFS_CAP = 20;

  // Full data from CSV
  let charities = {};             // EIN -> { name, receipt_amt, govt_amt, contrib_amt, grant_amt }
  let edgeAccumulator = {};       // "filer~grantee" -> totalGrant
  let totalCharitiesCount = 0;    // total charities read
  let totalGrantsCount = 0;       // total edges read from CSV

  // Filter state
  let activeEINs = [];
  let activeKeywords = [];

  // For BFS
  let dataReady = false;
  let panZoomInstance = null;

  $(document).ready(function() {

    // ADDED: Parse query params first
    parseQueryParams(); // ADDED

    // Load once
    loadData().then(() => {
      dataReady = true;
      $('#status').text('Data loaded.').css('color', 'black');
      // Generate graph right away (which will respect any pre-parsed EINs/keywords)
      generateGraph();
    }).catch(err => {
      console.error(err);
      $('#status').text('Failed to load data.').css('color', 'red');
    });

    // EIN handling
    $('#addEinBtn').on('click', addEINFromInput);
    $('#einInput').on('keypress', e => {
      if (e.key === 'Enter') addEINFromInput();
    });
    $('#clearEINsBtn').on('click', () => {
      activeEINs = [];
      renderActiveEINs();
      updateQueryParams(); // ADDED
      generateGraph();
    });

    // Keywords
    $('#addFilterBtn').on('click', addKeywordFromInput);
    $('#keywordInput').on('keypress', e => {
      if (e.key === 'Enter') addKeywordFromInput();
    });
    $('#clearFiltersBtn').on('click', () => {
      activeKeywords = [];
      renderActiveKeywords();
      updateQueryParams(); // ADDED
      generateGraph();
    });

    // Generate
    $('#generateBtn').on('click', generateGraph);

    // ADDED: Download SVG
    $('#downloadBtn').on('click', downloadSVG); // ADDED
  });

  /**
   * ADDED:
   * Parse query parameters (eins & keywords) and populate activeEINs, activeKeywords
   * Then render them in the UI so the user sees them.
   */
  function parseQueryParams() {
    const params = new URLSearchParams(window.location.search);

    // EINs
    const einParam = params.get('eins');
    if (einParam) {
      // e.g. eins=12-3456789,11-1111111 => after removing dashes => 9-digit check
      let list = einParam.split(',');
      list.forEach(e => {
        // remove dashes
        let v = e.replace(/[-\s]/g, '');
        if (/^\d{9}$/.test(v)) {
          // We'll add it if it's in our CSV or not - user might want it anyway
          if (!activeEINs.includes(v)) {
            activeEINs.push(v);
          }
        }
      });
    }

    // Keywords
    const kwParam = params.get('keywords');
    if (kwParam) {
      let kws = kwParam.split(',');
      kws.forEach(k => {
        k = k.trim().toLowerCase();
        if (k && !activeKeywords.includes(k)) {
          activeKeywords.push(k);
        }
      });
    }

    // Render them into their respective boxes
    renderActiveEINs();
    renderActiveKeywords();
  }

  /**
   * ADDED:
   * Update the query parameters to reflect the current activeEINs and activeKeywords.
   */
  function updateQueryParams() {
    const params = new URLSearchParams();
    if (activeEINs.length > 0) {
      // We'll allow the user to see them with dashes removed
      params.set('eins', activeEINs.join(','));
    }
    if (activeKeywords.length > 0) {
      params.set('keywords', activeKeywords.join(','));
    }
    const newUrl = window.location.pathname + '?' + params.toString();
    window.history.replaceState({}, '', newUrl);
  }

  /**
   * Load charities + grants from the CSV zips.
   */
  async function loadData() {
    $('#status').html('<span class="flex items-center text-sm"><img src="/assets/images/loading.svg" class="size-6" alt="Loading..."> Loading data...</span>');

    // 1) charities
    const charitiesZipBuf = await fetch('charities.csv.zip').then(r => r.arrayBuffer());
    const charitiesZip = await JSZip.loadAsync(charitiesZipBuf);
    const charitiesCsvString = await charitiesZip.file('charities_truncated.csv').async('string');

    await new Promise((resolve, reject) => {
      Papa.parse(charitiesCsvString, {
        header: true,
        skipEmptyLines: true,
        complete: results => {
          results.data.forEach(row => {
            const ein = (row['filer_ein'] || '').trim();
            if (!ein) return;
            let rAmt = parseInt((row['receipt_amt'] || '0').trim(), 10);
            if (isNaN(rAmt)) rAmt = 0;
            charities[ein] = {
              name: (row['filer_name'] || '').trim(),
              receipt_amt: rAmt,
              govt_amt: parseInt((row['govt_amt'] || '0').trim(), 10) || 0,
              contrib_amt: parseInt((row['contrib_amt'] || '0').trim(), 10) || 0,
              grant_amt: 0 // gets accumulated below
            };
          });
          totalCharitiesCount = Object.keys(charities).length;
          resolve();
        },
        error: err => reject(err)
      });
    });

    // 2) grants
    const grantsZipBuf = await fetch('grants.csv.zip').then(r => r.arrayBuffer());
    const grantsZip = await JSZip.loadAsync(grantsZipBuf);
    const grantsCsvString = await grantsZip.file('grants_truncated.csv').async('string');

    await new Promise((resolve, reject) => {
      Papa.parse(grantsCsvString, {
        header: true,
        skipEmptyLines: true,
        complete: results => {
          let localEdges = {};
          let count = 0;
          results.data.forEach(row => {
            const filer = (row['filer_ein'] || '').trim();
            const grantee = (row['grant_ein'] || '').trim();
            let amt = parseInt((row['grant_amt'] || '0').trim(), 10);
            if (isNaN(amt)) amt = 0;
            count++;

            if (charities[filer] && charities[grantee]) {
              const key = filer + '~' + grantee;
              if (!localEdges[key]) localEdges[key] = 0;
              localEdges[key] += amt;
              charities[filer].grant_amt += amt;
            }
          });
          edgeAccumulator = localEdges;
          totalGrantsCount = count;
          resolve();
        },
        error: err => reject(err)
      });
    });
  }

  /**
   * Build a filtered subset of charities + edges:
   *   - If activeKeywords is non-empty, a charity must match at least one or be in activeEINs.
   *   - If no keywords, we include all charities plus the user EINS.
   */
  function buildFilteredData() {
    let filteredCharities = {};
    const hasKeywords = (activeKeywords.length > 0);

    for (const [ein, c] of Object.entries(charities)) {
      if (activeEINs.includes(ein)) {
        // Always keep user-specified EIN
        filteredCharities[ein] = c;
        continue;
      }
      if (hasKeywords) {
        // Must match at least one keyword
        const nm = c.name.toLowerCase();
        const matched = activeKeywords.some(kw => nm.includes(kw));
        if (matched) {
          filteredCharities[ein] = c;
        }
      } else {
        // No keywords => keep everything
        filteredCharities[ein] = c;
      }
    }

    // Filter edges so that both ends are in the filtered set
    let filteredEdges = {};
    for (const [key, amt] of Object.entries(edgeAccumulator)) {
      const [filer, grantee] = key.split('~');
      if (filteredCharities[filer] && filteredCharities[grantee]) {
        filteredEdges[key] = amt;
      }
    }

    return { filteredCharities, filteredEdges };
  }

  /**
   * Multi-step BFS: 
   *  1) Pick the largest receipt_amt root from among user EINs (if any in the filtered set),
   *     otherwise the largest from the entire filtered set.
   *  2) BFS from that root (both directions). 
   *  3) If the subgraph has < 5 nodes, pick the next-largest unvisited charity, BFS again, union the sets.
   *  4) Keep going until subgraph has >=5 nodes or no more BFS roots remain.
   */
  function multiRootBFS(filteredCharities, adjacencyFwd, adjacencyRev) {
    const visited = new Set();
    const allEINs = Object.keys(filteredCharities);

    // Sort them by descending receipt_amt
    let sortedByReceipt = allEINs.slice().sort((a,b) => {
      return filteredCharities[b].receipt_amt - filteredCharities[a].receipt_amt;
    });

    // If user EINs exist in the filtered set, we want the largest of those first
    let hasUserEINsInFiltered = activeEINs.filter(x => allEINs.includes(x));
    if (hasUserEINsInFiltered.length > 0) {
      // Among those user EINs, find the one with largest receipt_amt
      let largestUserEIN = hasUserEINsInFiltered.reduce((best, cur) => {
        if (!best) return cur;
        const bestAmt = filteredCharities[best].receipt_amt;
        const curAmt = filteredCharities[cur].receipt_amt;
        return (curAmt > bestAmt) ? cur : best;
      }, null);

      // BFS from that root
      bfsFromRoot(largestUserEIN, adjacencyFwd, adjacencyRev, visited);

      // Then remove that root from the sorted array's priority
      sortedByReceipt = sortedByReceipt.filter(x => x !== largestUserEIN);
    }

    // If we still have fewer than 5, BFS from next largest unvisited
    let idx = 0;
    while (visited.size < 5 && idx < sortedByReceipt.length) {
      const candidate = sortedByReceipt[idx];
      if (!visited.has(candidate)) {
        bfsFromRoot(candidate, adjacencyFwd, adjacencyRev, visited);
      }
      idx++;
    }

    return visited;
  }

  /**
   * BFS forward + reverse from a single root, union results into visited.
   */
  function bfsFromRoot(root, adjacencyFwd, adjacencyRev, visited) {
    if (!root) return;
    // forward BFS
    let queue = [root];
    const localFwd = new Set();
    while (queue.length > 0 && localFwd.size < BFS_CAP) {
      const curr = queue.shift();
      if (!localFwd.has(curr)) {
        localFwd.add(curr);
        const neighs = adjacencyFwd[curr] || [];
        for (let n of neighs) {
          if (!localFwd.has(n) && localFwd.size < BFS_CAP) {
            queue.push(n);
          }
        }
      }
    }
    // reverse BFS
    const localRev = new Set();
    queue = [root];
    while (queue.length > 0 && localRev.size < BFS_CAP) {
      const curr = queue.shift();
      if (!localRev.has(curr)) {
        localRev.add(curr);
        const neighs = adjacencyRev[curr] || [];
        for (let n of neighs) {
          if (!localRev.has(n) && localRev.size < BFS_CAP) {
            queue.push(n);
          }
        }
      }
    }
    // union
    for (let x of localFwd) visited.add(x);
    for (let x of localRev) visited.add(x);
  }

  /**
   * The main "generate graph" function:
   *  1) Filter data
   *  2) Build adjacency
   *  3) multiRootBFS => visited set
   *  4) Force all user EINs
   *  5) Build final subgraph edges + direct user-EIN edges
   *  6) Summation of taxpayer money
   *  7) Render
   */
  function generateGraph() {
    if (!dataReady) {
      alert("Data not loaded yet. Please wait.");
      return;
    }

    // Clear old graph
    $('#graph-container').empty();
    $('#excluded-info').hide();
    if (panZoomInstance) {
      panZoomInstance.destroy();
      panZoomInstance = null;
    }

    $('#status').text('Generating...').css('color', 'red');
    $('#generateBtn').prop('disabled', true);

    // Build filtered dataset
    const { filteredCharities, filteredEdges } = buildFilteredData();
    const filteredEINs = Object.keys(filteredCharities);
    if (filteredEINs.length === 0) {
      $('#status').text('No charities match the filters.').css('color','black');
      $('#generateBtn').prop('disabled', false);
      return;
    }

    // Build adjacency
    const adjacencyFwd = {};
    const adjacencyRev = {};
    for (const [key, amt] of Object.entries(filteredEdges)) {
      const [filer, grantee] = key.split('~');
      if (!adjacencyFwd[filer]) adjacencyFwd[filer] = [];
      adjacencyFwd[filer].push(grantee);

      if (!adjacencyRev[grantee]) adjacencyRev[grantee] = [];
      adjacencyRev[grantee].push(filer);
    }

    // Multi-root BFS
    let visitedSet = multiRootBFS(filteredCharities, adjacencyFwd, adjacencyRev);

    // Force user EINs
    for (const e of activeEINs) {
      if (filteredCharities[e]) {
        visitedSet.add(e);
      }
    }

    // Build final edges
    const finalEdges = [];
    for (const [key, amt] of Object.entries(filteredEdges)) {
      const [filer, grantee] = key.split('~');
      if (visitedSet.has(filer) && visitedSet.has(grantee)) {
        finalEdges.push({ filer, grantee, amt });
      }
    }

    // Also forcibly include direct edges among user EINs if they exist
    for (let i = 0; i < activeEINs.length; i++) {
      for (let j = i + 1; j < activeEINs.length; j++) {
        const e1 = activeEINs[i];
        const e2 = activeEINs[j];
        // fwd
        if (filteredEdges[e1 + '~' + e2]) {
          const amt = filteredEdges[e1 + '~' + e2];
          if (!finalEdges.find(x => x.filer===e1 && x.grantee===e2)) {
            finalEdges.push({ filer: e1, grantee: e2, amt });
          }
          visitedSet.add(e1);
          visitedSet.add(e2);
        }
        // rev
        if (filteredEdges[e2 + '~' + e1]) {
          const amt = filteredEdges[e2 + '~' + e1];
          if (!finalEdges.find(x => x.filer===e2 && x.grantee===e1)) {
            finalEdges.push({ filer: e2, grantee: e1, amt });
          }
          visitedSet.add(e1);
          visitedSet.add(e2);
        }
      }
    }

    // Calculate excluded stats, taxpayer total
    const displayedNodesCount = visitedSet.size;
    const excluded501 = totalCharitiesCount - displayedNodesCount;
    const totalFilteredEdgesCount = Object.keys(filteredEdges).length;
    const displayedEdgesCount = finalEdges.length;
    const excludedGrants = totalFilteredEdgesCount - displayedEdgesCount;

    // Sum taxpayer funds in subgraph
    let taxpayerTotal = 0;
    for (const ein of visitedSet) {
      taxpayerTotal += (filteredCharities[ein].govt_amt || 0);
    }

    // Build DOT
    const dot = buildDotSource(visitedSet, finalEdges, filteredCharities, taxpayerTotal);

    // Render
    const viz = new Viz();
    viz.renderSVGElement(dot)
      .then(svgEl => {
        svgEl.setAttribute('width', '100%');
        svgEl.setAttribute('height', '100%');
        svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svgEl.setAttribute('class', 'w-full h-full');
        svgEl.setAttribute('style', 'min-height: 75vh;');

        $('#graph-container').append(svgEl);
        panZoomInstance = svgPanZoom(svgEl, {
          zoomEnabled: true,
          controlIconsEnabled: true,
          fit: true,
          center: true
        });

        // Show excluded info
        $('#excluded501').text(excluded501.toLocaleString());
        $('#excludedGrants').text(excludedGrants.toLocaleString());
        $('#taxpayerTotal').html(
          `<span class="md:text-lg text-red-500">$${formatNumber(taxpayerTotal)}</span>`
        );
        $('#excluded-info').show();

        $('#status').html(`<span class="text-sm text-green-600 font-semibold">${visitedSet.size} charities displayed</span>`);
        $('#downloadBtn').show();
        $('#generateBtn').prop('disabled', false);
      })
      .catch(err => {
        console.error(err);
        $('#status').text('Error generating graph.').css('color', 'red');
        $('#generateBtn').prop('disabled', false);
      });
  }

  /**
   * Build DOT string. We also highlight "Taxpayer Funds Received" in the label.
   */
  function buildDotSource(nodeSet, edgeList, filteredCharities, taxpayerTotal) {
    let dot = `digraph G {
// Graph settings
rankdir=LR;
node [
  shape=box,
  style="rounded,filled",
  fillcolor="#F3F4F6",
  color="#94A3B8",
  fontname="SF Pro, Helvetica, sans-serif",
  fontsize=14,
  margin=0.2,
  penwidth=1.5
];
edge [
  fontname="SF Pro, Helvetica, sans-serif",
  color="#94A3B8",
  penwidth=1.5,
  fontsize=11,
  decorate=true,
  labelangle=0,
  labeldistance=2
];
graph [
  fontname="SF Pro, Helvetica, sans-serif",
  splines=polyline
];
label="Charity Graph (multi-root BFS)";
labelloc="t";
`;

    // Add nodes
    for (const ein of nodeSet) {
      const c = filteredCharities[ein];
      
      // First escape special characters
      let escapedName = c.name.replace(/[&<>"']/g, char => {
        switch (char) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case "'": return '&apos;';
          default: return char;
        }
      });

      // Highlight keywords in the name
      if (activeKeywords.length > 0) {
        activeKeywords.forEach(kw => {
          // Case-insensitive search, preserve leading and trailing whitespace
          const regex = new RegExp(`(\\s*)(${kw})`, 'gi');
          escapedName = escapedName.replace(regex, '$1<B><FONT COLOR="#2563EB">$2</FONT></B> ').trim();
        });
      }
      
      const receipts = formatNumber(c.receipt_amt);
      const govt = formatNumber(c.govt_amt);
      const contrib = formatNumber(c.contrib_amt);
      const grants = formatNumber(c.grant_amt);
      
      // Enhanced table formatting - removed outer <B> tags
      const label = `<<TABLE BORDER="0" CELLBORDER="0" CELLSPACING="3" CELLPADDING="2">
        <TR><TD COLSPAN="2">${escapedName}</TD></TR>
        <TR>
          <TD ALIGN="LEFT"><FONT POINT-SIZE="12">EIN:</FONT></TD>
          <TD ALIGN="RIGHT"><FONT POINT-SIZE="12">${ein}</FONT></TD>
        </TR>
        <TR>
          <TD ALIGN="LEFT"><FONT POINT-SIZE="12">Gross Receipts:</FONT></TD>
          <TD ALIGN="RIGHT"><FONT POINT-SIZE="12">$${receipts}</FONT></TD>
        </TR>
        <TR>
          <TD ALIGN="LEFT" ${c.govt_amt > 0 ? 'COLOR="#DC2626"' : ''}>
            <FONT POINT-SIZE="12"><B>Taxpayer Funds:</B></FONT>
          </TD>
          <TD ALIGN="RIGHT" ${c.govt_amt > 0 ? 'COLOR="#DC2626"' : ''}>
            <FONT POINT-SIZE="12"><B>$${govt}</B></FONT>
          </TD>
        </TR>
        <TR>
          <TD ALIGN="LEFT"><FONT POINT-SIZE="12">Contributions:</FONT></TD>
          <TD ALIGN="RIGHT"><FONT POINT-SIZE="12">$${contrib}</FONT></TD>
        </TR>
        <TR>
          <TD ALIGN="LEFT"><FONT POINT-SIZE="12">Grants Given:</FONT></TD>
          <TD ALIGN="RIGHT"><FONT POINT-SIZE="12">$${grants}</FONT></TD>
        </TR>
      </TABLE>>`;
      
      // Style based on taxpayer funds AND user search
      let nodeStyle = '';
      if (activeEINs.includes(ein)) {
        // Highlight user-searched nodes with a thicker border and different color
        if (c.govt_amt > 10000000) {
          nodeStyle = 'fillcolor="#FEE2E2" color="#DC2626" penwidth=3';
        } else if (c.govt_amt > 1000000) {
          nodeStyle = 'fillcolor="#FEF3C7" color="#D97706" penwidth=3';
        } else if (c.govt_amt > 0) {
          nodeStyle = 'fillcolor="#F3F4F6" color="#2563EB" penwidth=3';  // Blue for emphasis
        } else {
          nodeStyle = 'fillcolor="#F3F4F6" color="#2563EB" penwidth=3';  // Blue for emphasis
        }
      } else {
        // Normal styling for other nodes
        if (c.govt_amt > 10000000) {
          nodeStyle = 'fillcolor="#FEE2E2" color="#DC2626"';
        } else if (c.govt_amt > 1000000) {
          nodeStyle = 'fillcolor="#FEF3C7" color="#D97706"';
        } else if (c.govt_amt > 0) {
          nodeStyle = 'fillcolor="#F3F4F6" color="#4B5563"';
        } else {
          nodeStyle = 'fillcolor="#F3F4F6" color="#94A3B8"';
        }
      }

      dot += `  "${ein}" [${nodeStyle}, label=${label}];\n`;
    }

    // Add edges - explicitly set color for each edge
    for (const e of edgeList) {
      const amt = formatNumber(e.amt);
      dot += `  "${e.filer}" -> "${e.grantee}" [label="$${amt}", color="#94A3B8"];\n`;
    }

    dot += `}\n`;
    return dot;
  }

  // Format number with commas
  function formatNumber(x) {
    const n = parseInt(x, 10) || 0;
    return n.toLocaleString('en-US');
  }

  /**
   * EIN input => add to activeEINs if valid
   */
  function addEINFromInput() {
    let val = $('#einInput').val().trim();
    val = val.replace(/[-\s]/g, '');
    if (!/^\d{9}$/.test(val)) {
      alert("EIN must be 9 digits after removing dashes/spaces.");
      return;
    }
    if (!charities[val]) {
      // Not found in CSV, but let's allow it anyway if user insists
      console.warn("EIN not found in charities.csv (still adding).");
    }
    if (!activeEINs.includes(val)) {
      activeEINs.push(val);
    }
    $('#einInput').val('');
    renderActiveEINs();
    updateQueryParams(); // ADDED
    generateGraph();
  }

  function renderActiveEINs() {
    const $c = $('#activeEINs');
    $c.empty();
    activeEINs.forEach(ein => {
      const $tag = $('<div class="filter-tag flex items-center gap-0.5 rounded border border-blue-600 bg-blue-100 text-blue-600 rounded-md px-2 py-1 bg-blue-100 text-xs"></div>');
      const $text = $('<span></span>').text(ein);
      const $rm = $('<span class="remove-filter opacity-50 hover:opacity-100 size-5 -my-0.5 -mr-1 cursor-pointer">{% include close.html %}</span>').attr('data-ein', ein);
      $rm.on('click', function() {
        const rem = $(this).attr('data-ein');
        activeEINs = activeEINs.filter(x => x !== rem);
        renderActiveEINs();
        updateQueryParams(); // ADDED
        generateGraph();
      });
      $tag.append($text).append($rm);
      $c.append($tag);
    });
  }

  /**
   * Keyword input => add to activeKeywords
   */
  function addKeywordFromInput() {
    const kw = $('#keywordInput').val().trim();
    if (kw.length > 0) {
      activeKeywords.push(kw.toLowerCase());
      $('#keywordInput').val('');
      renderActiveKeywords();
      updateQueryParams(); // ADDED
      generateGraph();
    }
  }

  function renderActiveKeywords() {
    const $c = $('#activeFilters');
    $c.empty();
    activeKeywords.forEach(kw => {
      const $tag = $('<div class="filter-tag flex items-center gap-0.5 rounded border border-blue-600 bg-blue-100 text-blue-600 rounded-md px-2 py-1 bg-blue-100 text-xs"></div>');
      const $text = $('<span></span>').text(kw);
      const $rm = $('<span class="remove-filter opacity-50 hover:opacity-100 size-5 -my-0.5 -mr-1 cursor-pointer">{% include close.html %}</span>').attr('data-kw', kw);
      $rm.on('click', function() {
        const rem = $(this).attr('data-kw');
        activeKeywords = activeKeywords.filter(x => x !== rem);
        renderActiveKeywords();
        updateQueryParams(); // ADDED
        generateGraph();
      });
      $tag.append($text).append($rm);
      $c.append($tag);
    });
  }

  /**
   * ADDED:
   * Download the currently displayed SVG as a file named "charity_graph.svg".
   */
  function downloadSVG() {
    const svgEl = document.querySelector('#graph-container svg');
    if (!svgEl) {
      alert('No SVG to download yet.');
      return;
    }
    const svgData = new XMLSerializer().serializeToString(svgEl);
    const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const link = document.createElement('a');
    link.href = url;
    link.download = 'charity_graph.svg';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
</script>